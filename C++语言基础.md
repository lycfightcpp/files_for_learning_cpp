# 1 C/C++语言基础

**C++ 与 C 的区别**
>+ **思想上**：C++ 是面向对象的语言，而 C 是面向过程的结构化编程语言；
>+ **语法上**：C++具有重载、继承和多态三种特性；C++ 相比 C ，增加多许多类型安全的功能，比如强制类型转换；C++ 持泛型编程，比如模板类、函数模板等

**内存分配方式**
>+ 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。
>+ 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。
>+ 从堆上分配，亦称动态内存分配。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。

**内存四区**
>+ **栈区**：栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。
>+ **堆区**：堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。
>+ **全局区**：全局区中主要存放的数据有：全局变量、静态变量、常量（如字符串常量）。全局区的叫法有很多：全局区、静态区、数据区、全局静态区、静态全局区。
>+ **代码区**：存放 CPU 执行的机器指令。通常代码区是可共享的（即另外的执行程序可以调用它），使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是只读的，使其只读的原因是防止程序意外地修改了它的指令。另外，代码区还规划了局部变量的相关信息。(共享和只读)

**编译过程**
>+ 预处理阶段:对源代码文件中文件包含关系 (头文件)、预编译语句 (宏定义) 进行分析和替换，生成预编译文件。(.i)
>+ 编译阶段:将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件。(.s)
>+ 汇编阶段:将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件。(.o)
>+ 链接阶段:将多个目标文件及所需要的库连接成最终的可执行目标文件。(可执行文件)

**main 函数执行前还会执行什么代码**
>+ 全局对象的构造函数会在 main 函数之前执行。

**常量与变量的区别**
>+ 常量不可以改变值，在定义时必须初始化，不可以寻址，地址不可以赋给非常量指针。变量与之相反。常量具有相对较高的编译执行效率。

**全局变量与局部变量的区别**
>+ 全局变量随主程序创建而创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；
>+ 使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用。
>+ 操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。

**自增自减 前操作 与 后操作 的区别**
>+ 前操作优先级大于赋值运算符，后操作优先级小于赋值运算符。
>+ i++运用了累加器这个寄存器（eax）来进行加法运算，而++i则是运用了计数器这个寄存器（ecx）来进行加法运算。
>+ 在考虑自定义数据类型（主要是指类）的情况，因为前缀式（++i）可以返回对象的引用，而后缀式（i++）必须返回对象的值，所以导致在大对象的时候产生了较大的复制开销，引起效率降低，因此处理使用者自定义类型（注意不是指内建类型）的时候，应该尽可能的使用前缀式地增/递减。
>+ i++ 不能做左值，++i 可以。

**什么是左值和右值**
>+ 变量是左值，可以出现在赋值语句的左边。数字字面值是右值，不能被赋值。

**宏定义**
>+ 宏定义是替换操作，不做计算，宏定义的替换在编译前进行，所以不占用内存和编译时间。

**内联函数**
>+ 编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文），从而节省了每次调用函数带来的额外时间开支。但在选择使用内联函数时，必须在程序占用空间和程序执行效率之间进行权衡，因为过多的比较复杂的函数进行内联扩展将带来很大的存储资源开支。

**结构与联合**
>+ 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。
>+ 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。

**const**
>+ 用于定义常量；
>+ 修饰函数形式参数，无论是 const 对象还是普通对象都可以调用该函数；
>+ 修饰函数返回值；
>+ 修饰类的成员函数，使数据成员不能被修改。

**const 较 #define 的优点**
>+ const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。
>+ const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。

**static**
>+ **1.全局静态变量**。在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量。静态存储区，在整个程序运行期间一直存在。**初始化**:未经初始化的全局静态变量会被自动初始化为 0 (自动对象的值是任意的，除非他被显式初始化）;**作用域**:全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。
>+ **2.局部静态变量**。在局部变量之前加上关键字 static，局部变量就成为一个局部静态变量。内存中的位置:静态存储区。**初始化**:未经初始化的全局静态变量会被自动初始化为 0 (自动对象的值是任意的，除非他被显式初始化);**作用域**:作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变;
>+ **3.静态函数**。在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突;
>+ **4.类的静态成员**。在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用；
>+ **5.类的静态成员函数**。静态成员函数和静态数据成员一样,它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。静态成员函数不能直接引用类的非静态成员。

**extern**
>+ 扩展外部变量的作用域（在同一个文件范围内）
>+ 将外部变量的作用域扩展到其他文件
>+ 将外部函数（函数名前面没有加static关键字）的作用域扩展到其他文件
>+ extern "C":告诉编译器在编译时按着 C 的规则去翻译。

**volatile**
>+ volatile 和 const 是相反的，它用来表示数据是可变的、易变的，目的是不让 CPU 将数据缓存到寄存器，而是从原始的内存中读取。

**malloc**
>+ malloc 函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。malloc 采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块; 同时 malloc 采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。
>+ 当进行内存分配时，malloc 会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配; 当进行内存合并时，malloc 采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。
>+ malloc 在申请内存时，一般会通过 brk 或者 mmap 系统调用进行申请。其中当申请内存小于 128K 时，会使用系统函数 brk 在堆区中分配; 而当申请内存大于 128K 时，会使用系统函数 mmap 在映射区分配。

**new/delete && malloc/free**
>+ new/delete 是 C++ 的关键字，而 malloc/free 是 C 语言的库函数
>+ malloc/free 必须指明申请空间的大小
>+ 对于类类型的对象，malloc/free 不会调用构造函数和析构函数
>+ malloc 需要给定申请内存的大小，返回的指针需要强转。new 会调用构造函数，不用指定内存大小，返回的指针不用强转。
>+ delete 只会调用一次析构函数，而 delete[] 会调用每一个成员的析构函数。

**如何判断内存泄漏**
>+ 内存泄漏通常是由于调用了 malloc/new 等内存申请的操作, 但是缺少了对应的 free/delete。为了判断内存是否泄露，我们一方面可以使用 linux 环境下的内存泄漏检查工具 Valgrind,另一方面我们在写代码时可以添加内存申请和释放的统计功能,统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。使用智能指针避免内存泄漏。

# 2 引用和指针

**this指针**
>+ this指针指向当前对象本身，表示当前对象的地址。

**引用作为函数参数**
>+ 传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。
>+ 使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。
>+ 使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要对指针进行解引用，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。

**引用作为函数返回值**
>+ 好处：在内存中不产生被返回值的副本
>+ 不能返回局部变量的引用。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了 "无所指" 的引用，程序会进入未知状态。
>+ 不能返回函数内部 new 分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。
>+ 可以返回类成员的引用，但最好是 const。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。
>+ 流操作符重载返回值申明为 “引用” 
>+ 赋值操作符重载返回值申明为 “引用”。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100; 赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。

**指针与引用的区别**
>+ 引用不需要分配内存区域；
>+ 引用在创建的同时必须初始化；
>+ 引用一旦被初始化为指向一个对象，就不能改变为另一个对象的引用；
>+ 引用必须指向某个对象，不能指向空值。

**野指针**
>+ 指针变量没有被初始化。刚被创建时默认值是随机的。
>+ 释放之后，没有被置为 NULL。

# 3 面向对象

**面向对象与面向过程的区别**
>+ 面向过程是一种以过程为中心的编程思想，以算法进行驱动。面向对象是一种以对象为中心的编程思想，以消息进行驱动。
>+ 面向过程编程语言的组成为:程序 = 算法 + 数据，面向对象编程语言的组成为:程序 = 对象 + 消息。

**面向对象的特征**
>+ 封装、继承、多态。

**类和结构的区别**
>+ 实例化的类存储在内存的堆内，而结构存储在栈内，结构的执行效率相对较高。结构没有析构函数。结构不可以继承。一般来说结构用来处理较少的程序基础数据，而类用来处理复杂逻辑。
>+ 结构体的成员和成员函数在默认情况下都是公有的（public），类的成员和成员函数在默认情况下都是私有的（private）。

**只能用intialization list 而不能用 assignment**
>+ 当类中含有 const、reference 成员变量。对于 const 和 reference 类型成员变量，它们只能够被初始化而不能做赋值操作，因此只能用初始化列表。(调用 assignment 构造函数时，对象已被初始化，const 和 reference 已被赋予了默认值，而不能够再被赋值)

**抽象类**
>+ 含有纯虚函数的类称为抽象类，抽象类不能实例化对象。

**访问方式**
>+ public：可以被该类中的函数、子类的函数、友元函数访问，也可以由该类的对象访问；
>+ protected：可以被该类中的函数、子类的函数、友元函数访问，但不可以由该类的对象访问；
>+ private：可以被该类中的函数、友元函数访问，但不可以由子类的函数、该类的对象访问。

**静态成员**
>+ 因为其空间在全局数据区分配，属于所有本类的对象共享，所以，它不属于特定的类对象，在没产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它。

**多态**
>+ 编译时多态：体现在函数和运算符的重载上，和泛型编程
>+ 运行时多态：通过继承和虚函数来体现
>+ C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。在面向对象的程序设计中使用「多态」，能够增强程序的可扩充性，即程序需要修改或增加功能的时候，需要改动和增加的代码较少。
>+ 「多态」的关键在于通过基类指针或引用调用一个虚函数时，编译时不能确定到底调用的是基类还是派生类的函数，运行时才能确定。

**虚函数表**
>+ 每一个有「虚函数」的类（或有虚函数的类的派生类）都有一个「虚函数表」，该类的任何对象中都放着虚函数表的指针。「虚函数表」中列出了该类的「虚函数」地址。

**虚析构函数**
>+ 可以使父类指针释放子类对象。C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。
>+ 当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。

**拷贝构造函数形参能否进行值传递**
>+ 不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。

**explicit**
>+ explicit 构造函数用来防止隐式转换。

# 4 继承

**派生类与基类转换**
>+ 派生类总是可以转换为基类的引用类型。基类转换为派生类需要在确定安全的情况下，使用强制转换来进行转换。

**继承时访问级别变化**
>+ public 继承：基类成员保持自己的访问级别；
>+ protected 继承：基类的 public 和 protected 成员在派生类中维 protected 成员。基类的 private 成员保持为 private；
>+ private 继承：基类的所有成员在派生类中为 private 成员。

**深拷贝与浅拷贝**
>+ 如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝；反之，没有重新分配资源，就是浅拷贝。

# 5 STL

**顺序容器**和**关联容器**

**STL 组成**
>+ 容器、迭代器、仿函数、算法、分配器、配接器。他们之间的关系:分配器给容器分配存储空间，算法通过迭代器获取容器中的内容，仿函数可以协助算法完成各种操作，配接器用来套接适配仿函数。

**vector**
>+ 连续存储的容器，动态数组，在堆上分配空间；
>+ 底层：数组
>+ 2 倍容量增长。vector 增加（插入）新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加到最后(插入指定位置），然后调整迭代器。如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效。
>+ 访问 O(1)。插入删除操作时需要内存拷贝。
>+ 适用场景：经常随机访问，且不经常对非尾节点进行插入删除。

**list**
>+ 动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间。
>+ 底层：双向链表
>+ 访问性能很差，只能快速访问头尾节点；插入删除操作很快，常数时间；
>+ 适用场景：经常插入删除大量数据。


**map数据存放形式**
>+ map 是红黑树
>+ unordered_map 是哈希表

**vector && list 的区别**
>+ vector 底层实现是数组；list 是双向链表。
>+ vector 支持随机访问；list 不支持。
>+ vector 是顺序内存；list 不是。
>+ vector 插入删除会导致内存拷贝；list 不会。
>+ vector 一次性分配好内存，不够时进行 2 倍扩容；list 每次插入都会进行内存申请。
>+ vector 随机访问性能好，插入删除性能差；list 相反。

**map && set 的区别**
>+ map和set 都是C++的关联容器，其底层实现都是红黑树（RB-Tree)。由于 map和set所开放的各种操作接口，RB-tree也都提供了，所以几乎所有的map和set的操作行为，都只是转调 RB-tree 的操作行为。
>+ (1) map 中的元素是 key-value（关键字一值）对:关键字起到索引的作用，值则表示与索引相关联的数据; Set 与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。
>+ (2) set 的迭代器是 const 的，不允许修改元素的值; map 允许修改 value，但不允许修改 key。其原因是因为 map 和 set 是根据关键字排序来保证其有序性的，如果允许修改 key 的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了 map 和 set 的结构，导致 iterator 失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以 STL 中将 set 的迭代器设置成 const，不允许修改迭代器的值;而 map 的迭代器则不允许修改 key 值，允许修改 value 值。
>+ (3) map 支持下标操作，set 不支持下标操作。

**resize 与 reserve 的区别**
>+ resize():改变当前容器内含有元素的数量；
>+ reserve():改变当前容器的最大容量,它不会生成元素，只是确定这个容器允许放入多少对象，如果 reserve(len) 的值大于当前的 capacity()，那么会重新分配一块能存 len 个对象的空间，然后把之前的对象通过copy construtor 复制过来，销毁之前的内存。


**iterator**
>+ iterator 类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。
>+ iterator(迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。或者这样说可能更容易理解: iterator 模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由 iterator 提供的方法）访问聚合对象中的各个元素。

**iterator 与 指针 的区别**
>+ 迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，->、*、++、--等。迭代器封装了指针,是一个 “可遍历STL( Standard TemplateLibrary)容器内全部或部分元素” 的对象，本质是封装了原生指针。可以根据不同类型的数据结构来实现不同的++，--等操作。
>+ 迭代器返回的是对象引用而不是对象的值。

**allocator**
>+ STL 的分配器用于封装 STL 容器在内存管理上的底层细节。在 C++ 中，其内存配置和释放如下:
>+ new 运算分两个阶段:(1)调用::operator new配置内存;(2)调用对象构造函数构造对象内容;
>+ delete运算分两个阶段:(1)调用对象析构函数;(2)调用::operator delete释放内存。
>+ 为了精密分工，STL allocator将两个阶段操作区分开来:内存配置有alloc::allocate()负责，内存释放由alloc::deallocate()负责;对象构造由 ::construct() 负责，对象析构由 ::destroy() 负责。
>+ 同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL 采用了两级配置器,当分配的空间大小超过128B时,会使用第一级空间配置器;当分配的空间大小小于128B时，将使用第二级空间配置器。第一级空间配置器直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放,而第二级空间配置器采用了内存池技术, 通过空闲链表来管理内存。

**STL 内存优化**

# 6 类型转换

&ensp;&ensp;C 的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。

**const_cast**
>+ 用于将 const 变量转为非 const，移除变量的 const 属性。

**static_cast**
>+ 用于类层次结构中，父类和子类之间指针和引用的转换；进行上行转换，把子类对象的指针/引用转换为父类指针/引用，这种转换是安全的；进行下行转换，把父类对象的指针/引用转换成子类指针/引用，这种转换是不安全的，需要编写程序时来确认；
>+ 用于基本数据类型之间的转换，例如把 int 转 char，int 转 enum 等，需要编写程序时来确认安全性；
>+ 把 void 指针转换成目标类型的指针。
**dynamic_cast**
>+ 用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。
>+ 向下转化时，如果是非法的对于指针返回 NULL，对于引用抛出异常。
>+ 它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同(对象是否完整)来判断是否能够进行向下转换。

**reinterpret_cast**
>+ reinterpret_cast能够完成任意指针类型向任意指针类型的转换，即使它们毫无关联。该转换的操作结果是出现一份完全相同的二进制复制品，既不会有指向内容的检查，也不会有指针本身类型的检查。
>+ reinterpret_cast 运算符并不会改变括号中运算对象的值，而是对该对象从位模式上进行重新解释。

# 7 智能指针
&ensp;&ensp;动态内存管理经常会出现两种问题：一种是忘记释放内存，会造成内存泄漏；一种是尚有指针引用内存的情况下就释放了它，就会产生引用非法内存的指针。

&ensp;&ensp;智能指针的作用是管理一个指针，因为存在以下这种情况:申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

>>std::unique_ptr<T> ：独占资源所有权的指针。
>>std::shared_ptr<T> ：共享资源所有权的指针。
>>std::weak_ptr<T> ：共享资源的观察者，需要和 std::shared_ptr 一起使用，不影响资源的生命周期。

**auto_ptr** (c++98 的方案，CPP11 已经抛弃)
>+ 采用所有权模式
```cpp
#include <memory>

auto_ptr<string> p1 (new string ("Hello World")); 
auto_ptr<string> p2; 
p2 = p1; //auto_ptr不会报错.
```
**shared_ptr**
&ensp;&ensp;shared_ptr 实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在 “最后一个引用被销毁” 时候释放。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数。除了可以通过 new 来构造，还可以通过传入 auto_ptr, unique_ptr, weak_ptr 来构造。当我们调用 release() 时，当前指针会释放资源所有权，计数减一。当计数等于 0时，资源会被释放。
&ensp;&ensp;成员函数：
>+ use_count 返回引用计数的个数;
>+ unique 返回是否是独占所有权 (use_count 为 1);
>+ swap交换两个 shared_ptr 对象 (即交换所拥有的对象);
>+ reset 放弃内部对象的所有权或拥有对象的变更，会引起原有对象的引用计数的减少;
>+ get 返回内部对象 (指针)，由于已经重载了 () 方法，因此和直接使用对象是一样的, 如shared_ptr<int> sp(new int(1)); sp 与 sp.get() 是等价的。

**weak_ptr**
&ensp;&ensp;weak_ptr是一种不控制对象生命周期的智能指针，它指向一个 shared_ptr 管理的对象.进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个shared_ptr 或另一个weak_ptr 对象构造，它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr 相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和 shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。

&ensp;&ensp;为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。

**unique_ptr**
&ensp;&ensp;unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。

&ensp;&ensp;另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做。
```cpp
#include <memory>

unique_ptr<string> pu1(new string ("hello world")); 
unique_ptr<string> pu2; 
pu2 = pu1;                                      // #1 不允许
unique_ptr<string> pu3; 
pu3 = unique_ptr<string>(new string ("You"));   // #2 允许
```
&ensp;&ensp;既然 std::unique_ptr 不能复制，那么如何将一个 std::unique_ptr 对象持有的堆内存转移给另外一个呢？答案是使用移动构造，&ensp;&ensp;示例代码如下：
```cpp
#include <memory>

int main()
{
    std::unique_ptr<int> sp1(std::make_unique<int>(123));

    std::unique_ptr<int> sp2(std::move(sp1));

    std::unique_ptr<int> sp3;
    sp3 = std::move(sp2);

    return 0;
}
```